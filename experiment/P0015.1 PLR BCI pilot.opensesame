# Generated by OpenSesame 2.9.0 (Hesitant Heisenberg)
# Mon Oct 27 14:56:18 2014 (posix)
# <http://www.cogsci.nl/opensesame>

set mouse_backend "psycho"
set subject_parity "even"
set height "1024"
set font_family "mono"
set font_italic "no"
set synth_backend "legacy"
set title "Attend-and-click training"
set coordinates "relative"
set start "experiment"
set sampler_backend "legacy"
set transparent_variables "no"
set foreground "white"
set font_bold "no"
set description "A brain-computer interface based on covert attention and pupillometry"
set background "#4c4c4c"
set font_size "18"
set keyboard_backend "psycho"
set canvas_backend "psycho"
set compensation "0"
set bidi "no"
set subject_nr "0"
set width "1280"

define pygaze_start_recording _pygaze_start_recording
	set status_msg "start_trial [count_free_writing]"
	set description "Puts the eye tracker into recording mode"

define sketchpad blank
	set duration "0"
	set description "Displays stimuli"

define inline_script default_settings
	set _run ""
	___prepare__
	exp.set('mode2', '90upmirror')
	exp.set('ecc', 410)
	exp.set('size', 132)
	exp.set('likelihoodThr', 1.375)
	exp.set('showCue', 'no')
	exp.set('background', 'gray')
	__end__
	set description "Executes Python code"

define loop eight_options
	set repeat "4"
	set item "exp_sequence"
	set break_if "never"
	set column_order "target;itemIds"
	set cycles "8"
	set order "random"
	setcycle 0 target "A"
	setcycle 0 itemIds "ABCDEFGH"
	setcycle 1 target "B"
	setcycle 1 itemIds "ABCDEFGH"
	setcycle 2 target "C"
	setcycle 2 itemIds "ABCDEFGH"
	setcycle 3 target "D"
	setcycle 3 itemIds "ABCDEFGH"
	setcycle 4 target "E"
	setcycle 4 itemIds "ABCDEFGH"
	setcycle 5 target "F"
	setcycle 5 itemIds "ABCDEFGH"
	setcycle 6 target "G"
	setcycle 6 itemIds "ABCDEFGH"
	setcycle 7 target "H"
	setcycle 7 itemIds "ABCDEFGH"
	run exp_sequence

define sequence exp_sequence
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run pygaze_drift_correct "always"
	run pygaze_start_recording "always"
	run speak_target "always"
	run sketchpad "always"
	run select_target "always"
	run feedback "always"
	run blank "always"
	run pygaze_log "always"
	run logger "always"
	run pygaze_stop_recording "always"

define sequence experiment
	run pygaze_init "always"
	run form_base "always"
	run python_definitions "always"
	run two_options "[opt2] = yes"
	run four_options "[opt4] = yes"
	run eight_options "[opt8] = yes"
	run free_writing_loop "[free_writing] = yes"

define inline_script eye_tracker
	___run__
	if 'dummy' in exp.items['pygaze_init'].tracker_type:
		pylink = None
	else:
		import pylink
	
	def collectPupilTrace(itemArray, dur, fd=10):
		
		"""
		desc:
			Returns an array of recorded pupil-size values.
			
		arguments:
			itemArray:		An ItemArray object.
			dur:			The recording duration.
			fd:				The frame duration in milliseconds.
			
		returns:
			A numpy array that with a dur/fd length.
		"""
		
		t0 = self.time()
		a = np.zeros(dur/fd)
		_dt = 0
		while _dt < dur:		
			itemArray.show()
			if pylink != None:
				ps = exp.pygaze_eyetracker.pupil_size()
			else:
				# Use Y coordinate of mouse
				ps = my_mouse.get_pos()[0][1]
			dt = self.time()-t0
			a[int(_dt/fd):int(dt/fd)] = ps
			_dt = dt
			if my_keyboard.get_key()[0] == 'space':
				say(self.get('target'))
		return a
	__end__
	set _prepare ""
	set description "Eye-tracker functionality"

define feedback feedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 0 "<b>Fin de sU+00E9lection</b><br /><br />SuccU+00E8s: [correct_selection]<br />Nr. de tours: [rounds]<br />DurU+00E9e: [loop_rt] s<br /><br />Appuyez sur une touche pour continuer" center=1 color="green" font_family="sans" font_size=32 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define form_base form_base
	set rows "1;1;1;1;1;1"
	set cols "1"
	widget 0 0 1 1 label text="<span size=32>Select / Selectionnez</span>"
	widget 0 1 1 1 button var="opt2" text="2 (AB)"
	widget 0 2 1 1 button var="opt4" text="4 (ABCD)"
	widget 0 3 1 1 button var="opt8" text="8 (ABCDEFGH)"
	widget 0 4 1 1 button var="free_writing" text="Free writing / U+00C9criture libre"
	widget 0 5 1 1 checkbox var="stabilize" text="Gaze stabilization / Stabilisation de regard"


define loop four_options
	set repeat "4"
	set item "exp_sequence"
	set break_if "never"
	set column_order "target;itemIds"
	set cycles "4"
	set order "random"
	setcycle 0 target "A"
	setcycle 0 itemIds "ABCD"
	setcycle 1 target "B"
	setcycle 1 itemIds "ABCD"
	setcycle 2 target "C"
	setcycle 2 itemIds "ABCD"
	setcycle 3 target "D"
	setcycle 3 itemIds "ABCD"
	run exp_sequence

define sequence free_writing
	run pygaze_drift_correct "always"
	run _pygaze_start_recording "always"
	run free_writing_script "always"
	run pygaze_log "always"
	run logger "always"
	run pygaze_stop_recording "always"

define loop free_writing_loop
	set cycles "1"
	set column_order ""
	run free_writing

define inline_script free_writing_script
	___run__
	s = ''
	t0 = self.time()
	exp.pygaze_eyetracker.log('start_free_writing')
	while True:
		ch = getInput()
		if ch == 'Fin':
			break
		if ch == 'Arr' and len(s) > 0:
			s = s[:-1]
		else:
			s += ch
		say(s)
	t1 = self.time()
	exp.pygaze_eyetracker.log('var free_writing_result %s' % s)
	exp.pygaze_eyetracker.log('var free_writing_time %s' % (t0-t1))
	exp.pygaze_eyetracker.log('end_free_writing')
	__end__
	set _prepare ""

define inline_script get_input
	___run__
	def getInput():
		
		"""
		desc:
			Gets a single input character.
			
		returns:
			An input character
		"""
	
		exp.pygaze_eyetracker.log('start_get_input')
		items = {
			'ABCD'	: ['A', 'B', 'C', 'D'],
			'EFGH'	: ['E', 'F', 'G', 'H'],
			'IJKL'	: ['I', 'J', 'K', 'L'],
			'MNOP'	: ['M', 'N', 'O', 'P'],
			'QRST'	: ['Q', 'R', 'S', 'T'],
			'UVWX'	: ['U', 'V', 'W', 'X'],
			'YZ?!'	: ['Y', 'Z', '?', '!'],
			'F/A'	: ['Fin', 'Arr'],
			}
		itemKeys = [
			'IJKL',
			'EFGH',
			'ABCD',
			'F/A',
			'YZ?!',
			'UVWX',
			'QRST',
			'MNOP',
			]
		ia = ItemArray(itemKeys,
			ecc=self.get('ecc'),
			size=self.get('size'),
			bgScale=2
			)
		winner, rounds = ia.selectionLoop(
			target=None,
			mode2=self.get('mode2'),
			likelihoodThr=self.get('likelihoodThr'),
			cue=False
			)
		print 'Winner of first round %s' % winner.itemId
		ia = ItemArray(items[winner.itemId],
			ecc=self.get('ecc'),
			size=self.get('size'),
			bgScale=2
			)
		winner, rounds = ia.selectionLoop(
			target=None,
			mode2=self.get('mode2'),
			likelihoodThr=self.get('likelihoodThr'),
			cue=False
			)
		print 'Winner of second round %s' % winner.itemId
		exp.pygaze_eyetracker.log('end_get_input %s' % winner.itemId)
		return winner.itemId
	__end__
	set _prepare ""

define inline_script globals
	___run__
	import string
	import numpy as np
	import random
	import os
	from psychopy.visual import TextStim, GratingStim, ImageStim
	from openexp.keyboard import keyboard
	from openexp.mouse import mouse
	import subprocess
	
	my_keyboard = keyboard(exp, timeout=0)
	my_mouse = mouse(exp)
	xc = self.get('width')/2
	yc = self.get('height')/2
	__end__
	set _prepare ""
	set description "Global objects and import statements"

define inline_script item
	___run__
	class Item(object):
		
		"""
		desc:
			A single selectable item.
		"""
		
		def __init__(self, itemArray, itemId, angle, ecc, opacity=.5, color='green',
			size=64, brightness=1, mirror=False, bgScale=2):
				
			"""
			desc:
				constructor.
				
			arguments:
				itemArray:		An ItemArray object.
				itemId:			A string that is shown and identifies the item.
				angle:			
								The angular position of the item. This is in radians
								counterclockwise, starting from a 3 o'clock
								position.
				ecc:			The eccentricity of the item.
			
			keywords:
				opacity:		The opacity of the item-id string.
				color:			The color of the item-id string.
				size:			
								The size of the item, which corresponds to the
								height of the item-id string and the radius of the
								background patch.
				brightness:		The brightness of the background patch.			
				mirror:			Indicates whether a 'mirror' background patch
								should be shown as well.
				bgScale:		The size of the background relative to the
								items.
			"""
			
			self.itemArray = itemArray
			self.itemId = itemId
			self.opacity = .5
			self.color = color
			self.size = size
			self.lLikelihood = [1]
			self.angle = angle
			self.imScale = 1.5
			self.brightness = brightness
			self.ecc = ecc
			self.background = GratingStim(win, tex=None, mask='raisedCos',
				color=self.brightness, size=size*bgScale)
			self.showMirror = mirror
			self.mirror = GratingStim(win, tex=None, mask='raisedCos',
				color=self.brightness, size=size*bgScale)		
			path = os.path.join(exp.experiment_path, '__pool__', '%s.png' % itemId)
			if os.path.exists(path):
				self.stim = ImageStim(win, path, opacity=self.opacity)		
			else:
				self.stim = TextStim(win, itemId, opacity=self.opacity,
					color=self.color, height=size)		
			self.cue = GratingStim(win, tex=None, mask=None, color='green',
				size=(128,2))
			self.lPrediction = []
			self.lPupilSize = []
			self.setAngle(angle)
										
		def likelihood(self):
			
			"""
			desc:
				Determines the most recent likelihood estimate that this item is
				selected.
				
			returns:
				A likelihood value.
			"""
			
			if np.isnan(self.lLikelihood[-1]):
				return 1
			return self.lLikelihood[-1]
			
		def setBrightness(self, brightness):
			
			"""
			desc:
				Sets the brightness of the background patch.
				
			arguments:
				brightness:		A brightness value.
			"""
			
			self.background.setColor(brightness)
			self.brightness = brightness
			self.mirror.setColor(brightness)
			
		def setAngle(self, angle):
			
			"""
			desc:
				Sets the angle of the item.
				
			arguments:
				angle:		The new angle.
			"""
			
			self.angle = angle
			x = self.ecc * np.cos(angle)
			y = self.ecc * np.sin(angle)
			self.xy = x,y
			self.stim.pos = self.xy
			self.background.pos = self.xy
			self.mirror.pos = -x, -y
			self.cue.setOri(np.degrees(-angle))
			
		def setPupilSize(self, pupilSize):
			
			"""
			desc:
				Sets the most recently recorded pupil size, and estimate a new
				likelihood value.
				
			arguments:
				pupilSize:		A pupil-size value.
			"""
			
			self.lPrediction.append(self.brightness)
			self.lPupilSize.append(pupilSize)
			if len(self.lPupilSize) > 1:
				pupilSizeChange = 1. * self.lPupilSize[-1] / self.lPupilSize[-2]
				if self.lPrediction[-1] == 1 and self.lPrediction[-2] == -1:
					likelihood = self.lLikelihood[-1] / pupilSizeChange
				elif self.lPrediction[-1] == -1 and self.lPrediction[-2] == 1:
					likelihood = self.lLikelihood[-1] * pupilSizeChange
				else:
					likelihood = self.lLikelihood[-1]
				self.lLikelihood.append(likelihood)
				
		def setXY(self, xy):
			
			"""
			desc:
				Sets the position of the item.
				
			arguments:
				xy:		An xy coordinate tuple.
			"""
			
			self.xy = xy
			self.stim.pos = xy
			self.background.pos = xy
			self.mirror.pos = -xy[0], -xy[1]
			
		def show(self, background=True, gazePos=None, cue=False):
			
			"""
			desc:
				Shows the item.
				
			keywords:
				background:		Indicates whether background patch should be shown
								as well.
				gazePos:		An (x,y) tuple with the most recent gaze position,
								used to perform retinal stabilization.
				cue:			Indicates whether a cue should be shown.
			"""
	
			if gazePos != None:
				gx, gy = gazePos
				gx -= xc
				gy -= yc
				self.background.setPos( (self.xy[0]+gx, self.xy[1]-gy) )
			if background:
				self.background.draw()
				if self.showMirror:
					self.mirror.draw()
			if cue:
				self.cue.draw()
			if hasattr(self.stim, 'setHeight'):
				self.stim.setHeight(
					int(self.size*self.likelihood()/self.itemArray.meanLikelihood()))
			else:
				self.stim.setSize(
					int(self.imScale*self.size*self.likelihood()/self.itemArray.meanLikelihood()))
			self.stim.draw()
			
		def focus(self, steps=50):
			
			"""
			desc:
				Moves the item to the display center, indicating that it has been
				selected.
				
			keywords:
				steps:		The number of steps of the animation.
			"""
			
			x = np.linspace(self.xy[0], 0, steps)
			y = np.linspace(self.xy[1], 0, steps)		
			for i in range(steps):
				self.background.pos = x[i],y[i]
				self.stim.pos = x[i],y[i]
				self.mirror.pos = -x[i],-y[i]
				self.show()
				win.flip()
				
		def log(self, status='normal'):
			
			"""
			desc:
				Logs the item information.
				
			keywords:
				status:		The status of the item.
			"""
					
			exp.pygaze_eyetracker.log((u'item id="%s" status=%s likelihood=%s ecc=%s angle=%s '
				u'size=%s brightness=%s color=%s opacity=%s x=%s y=%s') % (
				self.itemId, status, self.likelihood(), self.ecc, self.angle,
				self.size, self.brightness, self.color, self.opacity, self.xy[0],
				self.xy[1]))
	__end__
	set _prepare ""
	set description "Class definition"

define inline_script itemArray
	___run__
	class ItemArray(object):
		
		"""
		desc:
			An array of selectable items.
		"""
		
		def __init__(self, itemIds, stabilize=False, check=True, ecc=310, size=64,
			debug=False, bgScale=2):
			
			"""
			desc:
				Constructor.
				
			arguments:
				itemIds:	A list of item-id strings. There should be an even
							number of elements.
			
			keywords:
				stabilize:	Indicates whether retinal stabilization should be
							enabled.
				check:		Indicates whether the trial should be paused when
							fixation is lost.
				ecc:		The items' eccentricity.
				size:		The items' size.
				debug:		Indicates whether debugging info should be shown.
				bgScale:	See item.
			"""
			
			if len(itemIds) not in [2, 4, 8, 16, 32]:
				raise Exception('Expecting a power-of-two number of item IDs')
			self.items = []
			self.stabilize = stabilize
			self.check = check
			self.ecc = ecc
			self.size = size		
			self.debug = debug
			brightness = random.choice([1,-1])
			angle = 0
			for itemId in itemIds:			
				self.items.append(Item(self, itemId=itemId, angle=angle,
					ecc=ecc, brightness=brightness, size=size, bgScale=bgScale))
				brightness *= -1
				angle += 2*np.pi/len(itemIds)
			self.fixDot = GratingStim(win, tex=None, mask='circle', color='green',
				size=8)
			self.pupilSizeIndicator = TextStim(win, '-', pos=(xc-50, yc-20),
				color='black')
			self.pause = TextStim(win, 'Fixation lost')
				
		def show(self, background=True, cue=None):
			
			"""
			desc:
				Shows the ItemArray.
				
			keywords:
				background:		Indicates whether the backgrounds of the items
								should be shown as well.
				cue:			Indicates the item that should be cued, or None.
			"""
					
			if self.check:
				nErr = 0
				while True:
					gx, gy = exp.pygaze_eyetracker.sample()				
					gx -= xc
					gy -= yc
					err = np.sqrt(gx**2+gy**2)
					if err <= 100:
						break
					nErr += 1
					if nErr > 10:
						exp.pygaze_eyetracker.log('pause fixation_lost')
						self.pause.draw()
						win.flip()
						my_keyboard.flush()					
			if self.stabilize:
				gazePos = gx+xc, gy+yc
			else:
				gazePos = None
			for item in self.items:			
				if item.itemId == cue:
					showCue = True
				else:
					showCue = False
				item.show(background=background, gazePos=gazePos, cue=showCue)
			self.fixDot.draw()
			if self.debug:
				self.pupilSizeIndicator.draw()
			win.flip()
			
		def meanLikelihood(self):
			
			"""
			returns:
				The mean likelihood of all items.
			"""
			
			return np.mean([item.likelihood() for item in self.items])
			
		def invert(self, dur=500):
			
			"""
			desc:
				Inverts the brightness of all items.
				
			keywords:
				steps:	The duration of the inversion animation.
			"""
			
			f = np.linspace(1, -1, dur)
			oldBrightness = np.array([item.brightness for item in self.items])
			t0 = exp.time()
			i = 0
			while i < dur:			
				n = 0			
				for item in self.items:
					item.setBrightness(oldBrightness[n] * f[i])
					n += 1
				print 'i = %s' % i
				self.show()
				t1 = exp.time()
				i = int(t1-t0)
			n = 0
			for item in self.items:
				item.setBrightness(oldBrightness[n] * f[-1])
				n += 1
				
		def setMode2(self, mode2, steps=100):
			
			"""
			desc:
				See mode2 description in __init__().
				
			arguments:
				mode2:	See __init__().
			"""
			
			mode2 = str(mode2)
			assert(mode2 in ['180', '90up', '90down', '90upmirror', '90downmirror'])
			if len(self.items) != 2 or mode2 == '180':
				return
			if '90down' in mode2:
				# If item 0 is closer to the -.25pi angle than item 1
				if np.abs(self.items[0].angle+.25*np.pi) < \
					np.abs(self.items[1].angle+.25*np.pi):			
					a0 = -.25 * np.pi
					a1 = -.75 * np.pi
				else:
					a0 = -.75 * np.pi
					a1 = -.25 * np.pi				
			elif '90up' in mode2:
				# If item 0 is closer to the .25pi angle than item 1
				if np.abs(self.items[0].angle-.25*np.pi) < \
					np.abs(self.items[1].angle-.25*np.pi):			
					a0 = .25 * np.pi
					a1 = .75 * np.pi
				else:
					a0 = .75 * np.pi
					a1 = .25 * np.pi				
			if steps > 0:
				x0 = self.items[0].ecc*np.cos(a0)
				y0 = self.items[0].ecc*np.sin(a0)
				x1 = self.items[1].ecc*np.cos(a1)
				y1 = self.items[1].ecc*np.sin(a1)
				traceX0 = np.linspace(self.items[0].xy[0], x0, steps)
				traceY0 = np.linspace(self.items[0].xy[1], y0, steps)
				traceX1 = np.linspace(self.items[1].xy[0], x1, steps)
				traceY1 = np.linspace(self.items[1].xy[1], y1, steps)
				for i in range(steps):
					self.items[0].setXY((traceX0[i], traceY0[i]))
					self.items[1].setXY((traceX1[i], traceY1[i]))
					self.show()
			self.items[0].setAngle(a0)
			self.items[1].setAngle(a1)				
			if 'mirror' in mode2:
				self.items[0].showMirror = True
				self.items[1].showMirror = True
				
		def selectionLoop(self, initialSleep=1000, invertSteps=500, adaptDur=500,
			collectDur=250, target=None, mode2='180', likelihoodThr=2,
			cue=None):
			
			"""
			desc:
				Starts the selection loop, which ends when only one item is left.
				
			keywords:
				initialSleep:	The initial sleep duration.
				invertStep:		The number of franes for the invert animation.
				adaptDur:		The duration of the adaptation period.
				collectDur:		The duration of the pupil-size-collection period.
				target:			The target to be selected.
				mode2:			Indicates the mode of the final selection round, in
								which only two items are left. Should be '180',
								'90up', '90down', '90upmirror', or '90downmirror'.
				likelihoodThr:	The likelihood-ratio threshold. If 2, this means
								that items are pruned when their likelihood is less
								than 2 times the mean likelihood.
				cue:			Indicates the item that should be cued, or None to
								cue no items.
				
			returns:
				An (item, rounds) tuple containing the winning item and the number
				of rounds that the selection loop took.
			"""
			
			self.setMode2(mode2, steps=0)
			exp.pygaze_eyetracker.log('start_selection_loop')
			exp.pygaze_eyetracker.log('var target %s' % target)		
			exp.pygaze_eyetracker.log('var mode2 %s' % mode2)
			exp.pygaze_eyetracker.log('var stabilize %s' % self.stabilize)
			for item in self.items:
				item.log(status='init')		
			rounds = 0
			self.show(background=False, cue=cue)
			exp.sleep(initialSleep)
			self.show()
			collectPupilTrace(self, initialSleep)
			while True:				
				exp.pygaze_eyetracker.log('start_round %d' % rounds)			
				exp.pygaze_eyetracker.log('start_invert')
				self.invert(dur=invertSteps)
				exp.pygaze_eyetracker.log('end_invert')
				exp.pygaze_eyetracker.log('start_adaptation')
				collectPupilTrace(self, adaptDur)
				exp.pygaze_eyetracker.log('end_adaptation')
				exp.pygaze_eyetracker.log('start_collection')
				a = collectPupilTrace(self, collectDur)
				exp.pygaze_eyetracker.log('end_collection')
				meanPupilSize = np.median(a)
				self.pupilSizeIndicator.setText(str(meanPupilSize))
				for item in self.items:
					item.setPupilSize(meanPupilSize)				
				_items = []
				prune = False
				for item in self.items:
					if item.likelihood()*likelihoodThr >= self.meanLikelihood():
						item.log(status='keep')
						_items.append(item)
					else:
						item.log(status='prune')
						prune = True					
				self.items = _items			
				if prune:
					exp.pygaze_eyetracker.log('prune yes')
					self.setMode2(mode2)
					# Reshuffle the brightness of the items, but only if there are
					# still more than two items left. Otherwise we may change the
					# brightness of the winning item, which looks weird.
					if len(self.items) > 1:
						brightness = random.choice([1,-1])
						for item in self.items:
							item.setBrightness(brightness)
							brightness *= -1
				else:
					exp.pygaze_eyetracker.log('prune no')
				exp.pygaze_eyetracker.log('end_round')
				rounds += 1
				# Break if the target has been eliminated, if a target was specified
				if target != None:
					hit = False
					for item in self.items:
						if item.itemId == target:
							hit = True
					if not hit:
						break
				if len(self.items) == 1:
					break								
			if len(self.items) > 1:
				exp.set('correct_selection', 0)
				Item(self, '?', 0, self.ecc).focus()
				winner = None
			else:
				winner = self.items[0]
				winner.log(status='winner')
				winner.focus()
				if target == None:
					exp.set('correct_selection', -1)
				else:
					if winner.itemId == target:
						exp.set('correct_selection', 1)
						
					else:
						exp.set('correct_selection', 0)
			exp.pygaze_eyetracker.log('var rounds %d' % rounds)
			exp.pygaze_eyetracker.log('end_selection_loop')
			return winner, rounds
	__end__
	set _prepare ""
	set description "Class definition"

define logger logger
	set description "Logs experimental data"

define pygaze_drift_correct pygaze_drift_correct
	set xpos "0"
	set draw_target "yes"
	set ypos "0"
	set target_style "default"
	set target_color "[foreground]"
	set fixation_triggered "yes"
	set description "Perform eye-tracker drift correction"

define pygaze_init pygaze_init
	set sacc_acc_thr "9500"
	set description "Initialize and calibrate eye tracker"
	set tracker_type "Advanced dummy (mouse simulation)"
	set smi_send_port "4444"
	set eyelink_calbeep "yes"
	set smi_recv_port "5555"
	set sacc_vel_thr "35"
	set calibrate "yes"
	set eyelink_pupil_size_mode "area"
	set eyelink_force_drift_correct "yes"
	set _logfile "automatic"
	set calbeep "yes"

define pygaze_log pygaze_log
	set msg ""
	set throttle "2"
	set description "Writes information to the eye-tracker logfile"
	set auto_log "yes"

define pygaze_start_recording pygaze_start_recording
	set status_msg "start_trial [count_exp_sequence]"
	set description "Puts the eye tracker into recording mode"

define pygaze_stop_recording pygaze_stop_recording

define sequence python_definitions
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run default_settings "always"
	run globals "always"
	run speech "always"
	run smoothing "always"
	run item "always"
	run itemArray "always"
	run eye_tracker "always"
	run get_input "always"

define inline_script select_target
	___run__
	if self.get('showCue') == 'yes':
		cue = self.get('target')
	else:
		cue = None
	if self.get('stabilize') != 'no':
		stabilize = True
	else:
		stabilize = False
	ia = ItemArray(list(self.get('itemIds')),
		ecc=self.get('ecc'),
		size=self.get('size'),
		stabilize=stabilize
		)
	items = ia.items[:]
	t0 = self.time()
	winner, rounds = ia.selectionLoop(
		target=self.get('target'),
		mode2=self.get('mode2'),
		likelihoodThr=self.get('likelihoodThr'),
		cue=cue
		)
	t1 = self.time()
	rt = .001 * (t1-t0)
	exp.set('winner', winner)
	exp.set('rounds', rounds)
	exp.set('loop_rt', rt)
	self.sleep(2)
	__end__
	set _prepare ""
	set description "Executes Python code"

define sketchpad sketchpad
	set duration "keypress"
	set description "Displays stimuli"
	draw textline 0 0 "[target]" center=1 color="green" font_family="mono" font_size=64 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 -96 "Selectionnez" center=1 color="green" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"
	draw textline 0 96 "Appuyez sur une touche pour commencer" center=1 color="green" font_family="mono" font_size=18 font_bold="no" font_italic="no" html="yes" z_index=0 show_if="always"

define inline_script smoothing
	___run__
	import numpy
	
	def smooth(x, window_len=11, window='hanning'):
		"""
		desc:
			Smooths an array using a window with requested size and shape.
			
		source:
			<http://wiki.scipy.org/Cookbook/SignalSmooth>
		
		arguments:
			x:				The input array.
			
		keywords:
			window_len: 	The length of the window. Should be an odd integer.
			window:			The type of window from 'flat', 'hanning', 'hamming',
							'bartlett', 'blackman'.
	
		returns:
			A smoothed array.		
		"""
	
		if x.ndim != 1:
			raise ValueError, "smooth only accepts 1 dimension arrays."
		if x.size < window_len:
			raise ValueError, "Input vector needs to be bigger than window size."
		if window_len<3:
			return x
		if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
			raise ValueError, "Window is on of 'flat', 'hanning', 'hamming','bartlett', 'blackman'"
		s=numpy.r_[x[window_len-1:0:-1],x,x[-1:-window_len:-1]]
		if window == 'flat': #moving average
			w=numpy.ones(window_len,'d')
		else:
			w=eval('numpy.'+window+'(window_len)')
		y=numpy.convolve(w/w.sum(),s,mode='valid')
		return y
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script speak_target
	___run__
	say('Attendez %s' % self.get('target'))
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script speech
	___run__
	def say(msg):
		
		"""
		desc:
			Speak a message with the espeak synthesizer (if available).
			
		arguments:
			msg:	The message to speak.
		"""
		
		try:
			subprocess.Popen(['espeak', '-vfr', '-s', '140', msg])
		except:
			print('Text synthesis not available!')
	__end__
	set _prepare ""
	set description "Executes Python code"

define loop two_options
	set repeat "4"
	set item "exp_sequence"
	set break_if "never"
	set column_order "target;itemIds"
	set cycles "4"
	set order "random"
	setcycle 0 target "A"
	setcycle 0 itemIds "AB"
	setcycle 1 target "A"
	setcycle 1 itemIds "BA"
	setcycle 2 target "B"
	setcycle 2 itemIds "AB"
	setcycle 3 target "B"
	setcycle 3 itemIds "BA"
	run exp_sequence

