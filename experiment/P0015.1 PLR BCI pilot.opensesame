# Generated by OpenSesame 2.8.2 (Gutsy Gibson)
# Fri Jul 04 16:24:42 2014 (nt)
# <http://www.cogsci.nl/opensesame>

set mouse_backend "psycho"
set subject_parity "even"
set height "1024"
set font_family "mono"
set font_italic "no"
set synth_backend "legacy"
set title "P0015.1 PLR BCI Pilot"
set coordinates "relative"
set start "experiment"
set sampler_backend "legacy"
set transparent_variables "no"
set foreground "white"
set font_bold "no"
set description "Default description"
set background "gray"
set font_size "18"
set keyboard_backend "psycho"
set canvas_backend "psycho"
set compensation "0"
set bidi "no"
set subject_nr "0"
set width "1280"

define inline_script calibrate
	___run__
	ia = ItemArray(['X']*6)
	ia.show()
	
	nCycles = 10
	dur = 4000
	
	exp.eyelink.start_recording()
	
	aTrace = np.zeros([nCycles, dur/10])
	
	for i in range(nCycles):
		ia.invert()
		aTrace[i] = collectPupilTrace(ia, dur)
		
	exp.eyelink.stop_recording()
	
	mTrace = smooth(aTrace.mean(axis=0), window_len=11)
	mVel = mTrace[1:] - mTrace[:-1]
	velThr = np.abs(mVel).max() * .2
	iStable = np.where(np.abs(mVel) >= velThr)[0][-1]
	
	
	import os
	from matplotlib import pyplot as plt
	plt.subplot(211)
	plt.title('%d' % (iStable))
	plt.plot(np.rot90(aTrace), '--', color='gray')
	plt.plot(aTrace.mean(axis=0), '-', color='black')
	plt.xlim(0, len(mVel))
	plt.axvline(iStable, linestyle='--', color='gray')
	
	plt.subplot(212)
	plt.plot(mVel)
	plt.xlim(0, len(mVel))
	plt.axhline(-velThr, linestyle='--', color='gray')
	plt.axhline(velThr, linestyle='--', color='gray')
	plt.axvline(iStable, linestyle='--', color='gray')
	path = os.path.join(exp.experiment_path, 'plots/calibrate.png')	
	plt.savefig(path)
	plt.clf()
	exp.set('plot_path', path)
	__end__
	set _prepare ""
	set description "Executes Python code"

define feedback calibrationFeedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw image 0 0 "[plot_path]" scale=1 center=1 show_if="always"

define sequence calibrationSequence
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run calibrate "always"
	run calibrationFeedback "always"

define sequence experiment
	run eyelink_calibrate "always"
	run globals "always"
	run smoothing "always"
	run eye_tracker "always"
	run item "always"
	run itemArray "always"
	run calibrationSequence "never"
	run loop "always"

define inline_script eye_tracker
	___run__
	def collectPupilTrace(itemArray, dur, fd=10):
		
		"""
		desc:
			Returns an array of recorded pupil-size values.
			
		arguments:
			itemArray:		An ItemArray object.
			dur:			The recording duration.
			fd:				The frame duration in milliseconds.
			
		returns:
			A numpy array that with a dur/fd length.
		"""
		
		t0 = self.time()
		a = np.zeros(dur/fd)
		_dt = 0
		while _dt < dur:		
			itemArray.show()
			ps = exp.eyelink.pupil_size()
			dt = self.time()-t0
			a[int(_dt/fd):int(dt/fd)] = ps
			_dt = dt
			my_keyboard.flush()
		return a
	__end__
	set _prepare ""
	set description "Eye-tracker functionality"

define eyelink_calibrate eyelink_calibrate
	set sacc_vel_thresh "35"
	set cal_beep "yes"
	set description "Calibration/ initialization plugin for the Eyelink series of eye trackers (SR-Research)"
	set sacc_acc_thresh "9500"
	set cal_target_size "16"
	set force_drift_correct "yes"
	set tracker_attached "Yes"

define eyelink_drift_correct eyelink_drift_correct
	set ypos "0"
	set xpos "0"
	set mode "Automatic (fixation triggered)"
	set description "Drift correction plugin for the Eyelink series of eye trackers (SR-Research)"

define inline_script globals
	___run__
	import string
	import numpy as np
	import random
	from psychopy.visual import TextStim, GratingStim
	from openexp.keyboard import keyboard
	
	my_keyboard = keyboard(exp, timeout=0)
	xc = self.get('width')/2
	yc = self.get('height')/2
	__end__
	set _prepare ""
	set description "Global objects and import statements"

define inline_script item
	___run__
	class Item(object):
		
		"""
		desc:
			A single selectable item.
		"""
		
		def __init__(self, itemArray, itemId, angle, ecc, opacity=.5, color='green',
			size=64, brightness=1):
				
			"""
			desc:
				constructor.
				
			arguments:
				itemArray:		An ItemArray object.
				itemId:			A string that is shown and identifies the item.
				angle:			
								The angular position of the item. This is in radians
								counterclockwise, starting from a 3 o'clock
								position.
				ecc:			The eccentricity of the item.
			
			keywords:
				opacity:		The opacity of the item-id string.
				color:			The color of the item-id string.
				size:			
								The size of the item, which corresponds to the
								height of the item-id string and the radius of the
								background patch.
				brightness:		The brightness of the background patch.			
			"""
			
			self.itemArray = itemArray
			self.itemId = itemId
			self.opacity = .5
			self.color = color
			self.size = size
			self.lLikelihood = [1]
			self.angle = angle
			self.brightness = brightness
			self.ecc = ecc
			x = self.ecc * np.cos(self.angle)
			y = self.ecc * np.sin(self.angle)
			self.xy = x,y
			self.background = GratingStim(win, tex=None, mask='raisedCos',
				pos=self.xy, color=self.brightness, size=size*2)
			self.stim = TextStim(win, itemId, pos=self.xy, opacity=self.opacity,
				color=self.color, height=size)
			self.lPrediction = []
			self.lPupilSize = []
										
		def likelihood(self):
			
			"""
			desc:
				Determines the most recent likelihood estimate that this item is
				selected.
				
			returns:
				A likelihood value.
			"""
			
			return self.lLikelihood[-1]
			
		def setBrightness(self, brightness):
			
			"""
			desc:
				Sets the brightness of the background patch.
				
			arguments:
				brightness:		A brightness value.
			"""
			
			self.background.setColor(brightness)
			self.brightness = brightness
			
		def setPupilSize(self, pupilSize):
			
			"""
			desc:
				Sets the most recently recorded pupil size, and estimate a new
				likelihood value.
				
			arguments:
				pupilSize:		A pupil-size value.
			"""
			
			self.lPrediction.append(self.brightness)
			self.lPupilSize.append(pupilSize)
			if len(self.lPupilSize) > 1:
				pupilSizeChange = 1. * self.lPupilSize[-1] / self.lPupilSize[-2]
				if self.lPrediction[-1] == 1 and self.lPrediction[-2] == -1:
					likelihood = self.lLikelihood[-1] / pupilSizeChange
				elif self.lPrediction[-1] == -1 and self.lPrediction[-2] == 1:
					likelihood = self.lLikelihood[-1] * pupilSizeChange
				else:
					likelihood = self.lLikelihood[-1]
				self.lLikelihood.append(likelihood)
			
		def show(self, background=True, gazePos=None):
			
			"""
			desc:
				Shows the item.
				
			keywords:
				background:	
								Indicates whether background patch should be shown
								as well.
				gazePos:	
								An (x,y) tuple with the most recent gaze position,
								used to perform retinal stabilization.
			"""
	
			if gazePos != None:
				gx, gy = gazePos
				gx -= xc
				gy -= yc
				self.background.setPos( (self.xy[0]+gx, self.xy[1]-gy) )
			if background:
				self.background.draw()
			self.stim.setHeight(
				int(self.size*self.likelihood()/self.itemArray.meanLikelihood()))
			self.stim.draw()
			
		def focus(self, steps=100):
			
			"""
			desc:
				Moves the item to the display center, indicating that it has been
				selected.
				
			keywords:
				steps:		The number of steps of the animation.
			"""
			
			x = np.linspace(self.xy[0], 0, steps)
			y = np.linspace(self.xy[1], 0, steps)		
			for i in range(steps):
				self.background.pos = x[i],y[i]
				self.stim.pos = x[i],y[i]
				self.show()
				win.flip()
				
		def log(self, status='normal'):
			
			"""
			desc:
				Logs the item information.
				
			keywords:
				status:		The status of the item.
			"""
					
			exp.eyelink.log((u'item id="%s" status=%s likelihood=%d ecc=%d angle=%s '
				u'size=%s brightness=%s color=%s opacity=%s') % (self.itemId,
				status, self.likelihood(), self.ecc, self.angle, self.size,
				self.brightness, self.color, self.opacity))
	__end__
	set _prepare ""
	set description "Class definition"

define inline_script itemArray
	___run__
	class ItemArray(object):
		
		"""
		desc:
			An array of selectable items.
		"""
		
		def __init__(self, itemIds, stabilize=False, check=True, ecc=310, size=64):
			
			"""
			desc:
				Constructor.
				
			arguments:
				itemIds:
							A list of item-id strings. There should be an even
							number of elements.
			
			keywords:
				stabilize:
							Indicates whether retinal stabilization should be
							enabled.
				check:		
							Indicates whether the trial should be paused when
							fixation is lost.
				ecc:		The items' eccentricity.
				size:		The items' size.
			"""
			
			if len(itemIds) not in [2,4,8,16,32]:
				raise Exception('Expecting a power-of-two number of item IDs')
			self.items = []
			self.stabilize = stabilize
			self.check = check
			self.ecc = ecc
			self.size = size
			brightness = random.choice([1,-1])
			angle = 0
			for itemId in itemIds:			
				self.items.append(Item(self, itemId=itemId, angle=angle,
					ecc=ecc, brightness=brightness, size=size))
				brightness *= -1
				angle += 2*np.pi/len(itemIds)
			self.fixDot = GratingStim(win, tex=None, mask='circle', color='green',
				size=8)
			self.pause = TextStim(win, 'Fixation lost')
				
		def show(self, background=True):
			
			"""
			desc:
				Shows the ItemArray.
				
			keywords:
				background:		
								Indicates whether the backgrounds of the items
								should be shown as well.
			"""
					
			if self.check:
				nErr = 0
				while True:
					gx, gy = exp.eyelink.sample()				
					gx -= xc
					gy -= yc
					err = np.sqrt(gx**2+gy**2)
					if err <= 100:
						break
					nErr += 1
					if nErr > 10:
						exp.eyelink.log('pause fixation_lost')
						self.pause.draw()
						win.flip()
						my_keyboard.flush()					
			if self.stabilize:
				gazePos = xy
			else:
				gazePos = None
			for item in self.items:			
				item.show(background=background, gazePos=gazePos)
			self.fixDot.draw()
			win.flip()
			
		def meanLikelihood(self):
			
			"""
			returns:
				The mean likelihood of all items.
			"""
			
			return np.mean([item.likelihood() for item in self.items])
			
		def invert(self, steps=50):
			
			"""
			desc:
				Inverts the brightness of all items.
				
			keywords:
				steps:	The number of frames for the inversion animation.
			"""
			
			f = np.linspace(1, -1, steps)
			oldBrightness = np.array([item.brightness for item in self.items])
			for i in range(steps):
				n = 0			
				for item in self.items:
					item.setBrightness(oldBrightness[n] * f[i])
					n += 1
				self.show()
				
		def selectionLoop(self, initialSleep=1000, invertSteps=50, adaptDur=500,
			collectDur=250, target=None):
			
			"""
			desc:
				Starts the selection loop, which ends when only one item is left.
				
			keywords:
				initialSleep:	The initial sleep duration.
				invertStep:		The number of franes for the invert animation.
				adaptDur:		The duration of the adaptation period.
				collectDur:		The duration of the pupil-size-collection period.
				target:			The target to be selected.
				
			returns:
				An (item, rounds) tuple containing the winning item and the number
				of rounds that the selection loop took.
			"""
			
			exp.eyelink.log('start_selection_loop')
			exp.eyelink.log('var target %s' % target)		
			for item in self.items:
				item.log(status='init')		
			rounds = 0
			exp.eyelink.start_recording()		
			self.show(background=False)
			exp.sleep(initialSleep)
			self.show()
			collectPupilTrace(self, initialSleep)
			while True:
				exp.eyelink.log('start_round %d' % rounds)			
				exp.eyelink.log('start_invert')
				self.invert(steps=invertSteps)
				exp.eyelink.log('start_end')
				exp.eyelink.log('start_adaptation')
				collectPupilTrace(self, adaptDur)
				exp.eyelink.log('end_adaptation')
				exp.eyelink.log('start_collection')
				a = collectPupilTrace(self, collectDur)
				exp.eyelink.log('start_end')
				meanPupilSize = np.median(a)
				for item in self.items:
					item.setPupilSize(meanPupilSize)				
				_items = []
				prune = False
				for item in self.items:
					if item.likelihood()*2 >= self.meanLikelihood():
						item.log(status='keep')
						_items.append(item)
					else:
						item.log(status='prune')
						prune = True					
				self.items = _items
				if prune:
					exp.eyelink.log('prune yes')
					brightness = random.choice([1,-1])
					for item in self.items:
						item.setBrightness(brightness)
						brightness *= -1
				else:
					exp.eyelink.log('prune no')
				exp.eyelink.log('end_round')
				rounds += 1
				# Break if the target has been eliminated, if a target was specified
				if target != None:
					hit = False
					for item in self.items:
						if item.itemId == target:
							hit = True
					if not hit:
						break
				if len(self.items) == 1:
					break								
			if len(self.items) > 1:
				exp.eyelink.log('var correct 0')
				Item(self, '?', 0, self.ecc).focus()
				winner = None
			else:
				exp.eyelink.log('var correct 1')
				winner = self.items[0]
				winner.log(status='winner')
				winner.focus()
			exp.eyelink.log('var rounds %d' % rounds)
			exp.eyelink.log('end_selection_loop')
			exp.eyelink.stop_recording()		
			return winner, rounds
	__end__
	set _prepare ""
	set description "Class definition"

define keyboard_response keyboard_response

define loop loop
	set repeat "4"
	set description "Repeatedly runs another item"
	set item "sequence"
	set break_if "never"
	set column_order "setSize"
	set cycles "4"
	set order "random"
	setcycle 0 setSize "2"
	setcycle 1 setSize "4"
	setcycle 2 setSize "8"
	setcycle 3 setSize "16"
	run sequence

define inline_script select_target
	___run__
	ia = ItemArray(itemIds)
	items = ia.items[:]
	winner, rounds = ia.selectionLoop(target=self.get('target'))
	__end__
	set _prepare ""
	set description "Executes Python code"

define sequence sequence
	run trial_init "always"
	run sketchpad "always"
	run eyelink_drift_correct "always"
	run select_target "always"
	run keyboard_response "always"

define sketchpad sketchpad
	set duration "keypress"
	set description "Displays stimuli"
	draw textline 0.0 -96.0 "Attend to" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0.0 96.0 "Press any key to begin" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 0 "[target]" center=1 color=green font_family="mono" font_size=64 font_italic=no font_bold=no show_if="always" html="yes"

define inline_script smoothing
	___run__
	import numpy
	
	def smooth(x,window_len=11,window='hanning'):
		"""smooth the data using a window with requested size.
		
		This method is based on the convolution of a scaled window with the signal.
		The signal is prepared by introducing reflected copies of the signal 
		(with the window size) in both ends so that transient parts are minimized
		in the begining and end part of the output signal.
		
		input:
			x: the input signal 
			window_len: the dimension of the smoothing window; should be an odd integer
			window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
				flat window will produce a moving average smoothing.
	
		output:
			the smoothed signal
			
		example:
	
		t=linspace(-2,2,0.1)
		x=sin(t)+randn(len(t))*0.1
		y=smooth(x)
		
		see also: 
		
		numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
		scipy.signal.lfilter
	 
		TODO: the window parameter could be the window itself if an array instead of a string
		NOTE: length(output) != length(input), to correct this: return y[(window_len/2-1):-(window_len/2)] instead of just y.
		"""
	
		if x.ndim != 1:
			raise ValueError, "smooth only accepts 1 dimension arrays."
	
		if x.size < window_len:
			raise ValueError, "Input vector needs to be bigger than window size."
	
	
		if window_len<3:
			return x
	
	
		if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
			raise ValueError, "Window is on of 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'"
	
	
		s=numpy.r_[x[window_len-1:0:-1],x,x[-1:-window_len:-1]]
		#print(len(s))
		if window == 'flat': #moving average
			w=numpy.ones(window_len,'d')
		else:
			w=eval('numpy.'+window+'(window_len)')
	
		y=numpy.convolve(w/w.sum(),s,mode='valid')
		return y
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script trial_init
	set _run ""
	___prepare__
	from random import shuffle, choice
	from openexp.keyboard import keyboard
	import string
	
	setSize = self.get('setSize')
	itemIds = list(string.uppercase[:setSize])[::-1]
	exp.set('target', choice(itemIds))
	__end__
	set description "Executes Python code"

