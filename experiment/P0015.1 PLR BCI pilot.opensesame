# Generated by OpenSesame 2.8.2 (Gutsy Gibson)
# Wed Jul  9 14:43:40 2014 (posix)
# <http://www.cogsci.nl/opensesame>

set mouse_backend "psycho"
set subject_parity "even"
set height "1024"
set font_family "mono"
set font_italic "no"
set synth_backend "legacy"
set title "P0015.1 Attend and Click"
set coordinates "relative"
set start "experiment"
set sampler_backend "legacy"
set transparent_variables "no"
set foreground "white"
set font_bold "no"
set description "A brain-computer interface based on covert attention and pupillometry"
set background "gray"
set font_size "18"
set keyboard_backend "psycho"
set canvas_backend "psycho"
set compensation "0"
set bidi "no"
set subject_nr "0"
set width "1280"

define inline_script calibrate
	___run__
	ia = ItemArray(['X']*6)
	ia.show()
	
	nCycles = 10
	dur = 4000
	
	exp.pygaze_eyetracker.start_recording()
	
	aTrace = np.zeros([nCycles, dur/10])
	
	for i in range(nCycles):
		ia.invert()
		aTrace[i] = collectPupilTrace(ia, dur)
		
	exp.pygaze_eyetracker.stop_recording()
	
	mTrace = smooth(aTrace.mean(axis=0), window_len=11)
	mVel = mTrace[1:] - mTrace[:-1]
	velThr = np.abs(mVel).max() * .2
	iStable = np.where(np.abs(mVel) >= velThr)[0][-1]
	
	
	import os
	from matplotlib import pyplot as plt
	plt.subplot(211)
	plt.title('%d' % (iStable))
	plt.plot(np.rot90(aTrace), '--', color='gray')
	plt.plot(aTrace.mean(axis=0), '-', color='black')
	plt.xlim(0, len(mVel))
	plt.axvline(iStable, linestyle='--', color='gray')
	
	plt.subplot(212)
	plt.plot(mVel)
	plt.xlim(0, len(mVel))
	plt.axhline(-velThr, linestyle='--', color='gray')
	plt.axhline(velThr, linestyle='--', color='gray')
	plt.axvline(iStable, linestyle='--', color='gray')
	path = os.path.join(exp.experiment_path, 'plots/calibrate.png')	
	plt.savefig(path)
	plt.clf()
	exp.set('plot_path', path)
	__end__
	set _prepare ""
	set description "Executes Python code"

define sequence calibration
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run calibrate "always"
	run calibrationFeedback "always"

define feedback calibrationFeedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw image 0 0 "[plot_path]" scale=1 center=1 show_if="always"

define loop exp1
	set repeat "1"
	set description "Repeatedly runs another item"
	set item "exp1_sequence"
	set break_if "never"
	set column_order "mode2;target;itemIds"
	set cycles "20"
	set order "random"
	setcycle 0 mode2 "180"
	setcycle 0 target "A"
	setcycle 0 itemIds "AB"
	setcycle 1 mode2 "180"
	setcycle 1 target "B"
	setcycle 1 itemIds "AB"
	setcycle 2 mode2 "90up"
	setcycle 2 target "A"
	setcycle 2 itemIds "AB"
	setcycle 3 mode2 "90up"
	setcycle 3 target "B"
	setcycle 3 itemIds "AB"
	setcycle 4 mode2 "90down"
	setcycle 4 target "A"
	setcycle 4 itemIds "AB"
	setcycle 5 mode2 "90down"
	setcycle 5 target "B"
	setcycle 5 itemIds "AB"
	setcycle 6 mode2 "90upmirror"
	setcycle 6 target "A"
	setcycle 6 itemIds "AB"
	setcycle 7 mode2 "90upmirror"
	setcycle 7 target "B"
	setcycle 7 itemIds "AB"
	setcycle 8 mode2 "90downmirror"
	setcycle 8 target "A"
	setcycle 8 itemIds "AB"
	setcycle 9 mode2 "90downmirror"
	setcycle 9 target "B"
	setcycle 9 itemIds "AB"
	setcycle 10 mode2 "180"
	setcycle 10 target "A"
	setcycle 10 itemIds "BA"
	setcycle 11 mode2 "180"
	setcycle 11 target "B"
	setcycle 11 itemIds "BA"
	setcycle 12 mode2 "90up"
	setcycle 12 target "A"
	setcycle 12 itemIds "BA"
	setcycle 13 mode2 "90up"
	setcycle 13 target "B"
	setcycle 13 itemIds "BA"
	setcycle 14 mode2 "90down"
	setcycle 14 target "A"
	setcycle 14 itemIds "BA"
	setcycle 15 mode2 "90down"
	setcycle 15 target "B"
	setcycle 15 itemIds "BA"
	setcycle 16 mode2 "90upmirror"
	setcycle 16 target "A"
	setcycle 16 itemIds "BA"
	setcycle 17 mode2 "90upmirror"
	setcycle 17 target "B"
	setcycle 17 itemIds "BA"
	setcycle 18 mode2 "90downmirror"
	setcycle 18 target "A"
	setcycle 18 itemIds "BA"
	setcycle 19 mode2 "90downmirror"
	setcycle 19 target "B"
	setcycle 19 itemIds "BA"
	run exp1_sequence

define sequence exp1_sequence
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run pygaze_drift_correct "always"
	run pygaze_start_recording "always"
	run speak_target "always"
	run sketchpad "always"
	run select_target "always"
	run keyboard_response "always"
	run feedback "always"
	run pygaze_log "always"
	run logger "always"
	run pygaze_stop_recording "always"

define sequence experiment
	run pygaze_init "always"
	run form_base "always"
	run python_definitions "always"
	run calibration "[calibrate] = yes"
	run exp1 "[exp1] = yes"

define inline_script eye_tracker
	___run__
	try:
		import pylink
	except:
		pylink = None
	
	def collectPupilTrace(itemArray, dur, fd=10):
		
		"""
		desc:
			Returns an array of recorded pupil-size values.
			
		arguments:
			itemArray:		An ItemArray object.
			dur:			The recording duration.
			fd:				The frame duration in milliseconds.
			
		returns:
			A numpy array that with a dur/fd length.
		"""
		
		t0 = self.time()
		a = np.zeros(dur/fd)
		_dt = 0
		while _dt < dur:		
			itemArray.show()
			if pylink != None:
				ps = exp.pygaze_eyetracker.pupil_size()
			else:
				# Use Y coordinate of mouse
				ps = my_mouse.get_pos()[0][1]
			dt = self.time()-t0
			a[int(_dt/fd):int(dt/fd)] = ps
			_dt = dt
			if my_keyboard.get_key()[0] == 'space':
				say(self.get('target'))
		return a
	__end__
	set _prepare ""
	set description "Eye-tracker functionality"

define feedback feedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw textline 0 -96 "Selection made in" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 -32 "[rounds] rounds, and" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 448 "Press any key to continue" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 32 "[loop_rt] seconds" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"

define form_base form_base
	set rows "1;1;1"
	set cols "1"
	widget 0 0 1 1 label text="Select mode"
	widget 0 1 1 1 button var="calibrate" text="Calibrate"
	widget 0 2 1 1 button var="exp1" text="Exp. 1: Mode 2"


define inline_script globals
	___run__
	import string
	import numpy as np
	import random
	from psychopy.visual import TextStim, GratingStim
	from openexp.keyboard import keyboard
	from openexp.mouse import mouse
	import subprocess
	
	my_keyboard = keyboard(exp, timeout=0)
	my_mouse = mouse(exp)
	xc = self.get('width')/2
	yc = self.get('height')/2
	__end__
	set _prepare ""
	set description "Global objects and import statements"

define inline_script item
	___run__
	class Item(object):
		
		"""
		desc:
			A single selectable item.
		"""
		
		def __init__(self, itemArray, itemId, angle, ecc, opacity=.5, color='green',
			size=64, brightness=1, mirror=False):
				
			"""
			desc:
				constructor.
				
			arguments:
				itemArray:		An ItemArray object.
				itemId:			A string that is shown and identifies the item.
				angle:			
								The angular position of the item. This is in radians
								counterclockwise, starting from a 3 o'clock
								position.
				ecc:			The eccentricity of the item.
			
			keywords:
				opacity:		The opacity of the item-id string.
				color:			The color of the item-id string.
				size:			
								The size of the item, which corresponds to the
								height of the item-id string and the radius of the
								background patch.
				brightness:		The brightness of the background patch.			
				mirror:			Indicates whether a 'mirror' background patch
								should be shown as well.
			"""
			
			self.itemArray = itemArray
			self.itemId = itemId
			self.opacity = .5
			self.color = color
			self.size = size
			self.lLikelihood = [1]
			self.angle = angle
			self.brightness = brightness
			self.ecc = ecc
			self.background = GratingStim(win, tex=None, mask='raisedCos',
				color=self.brightness, size=size*2)
			self.showMirror = mirror
			self.mirror = GratingStim(win, tex=None, mask='raisedCos',
				color=self.brightness, size=size*2)
			self.stim = TextStim(win, itemId, opacity=self.opacity,
				color=self.color, height=size)		
			self.lPrediction = []
			self.lPupilSize = []
			self.setAngle(angle)
										
		def likelihood(self):
			
			"""
			desc:
				Determines the most recent likelihood estimate that this item is
				selected.
				
			returns:
				A likelihood value.
			"""
			
			return self.lLikelihood[-1]
			
		def setBrightness(self, brightness):
			
			"""
			desc:
				Sets the brightness of the background patch.
				
			arguments:
				brightness:		A brightness value.
			"""
			
			self.background.setColor(brightness)
			self.brightness = brightness
			self.mirror.setColor(brightness)
			
		def setAngle(self, angle):
			
			"""
			desc:
				Sets the angle of the item.
				
			arguments:
				angle:		The new angle.
			"""
			
			self.angle = angle
			x = self.ecc * np.cos(angle)
			y = self.ecc * np.sin(angle)
			self.xy = x,y
			self.stim.pos = self.xy
			self.background.pos = self.xy
			self.mirror.pos = -x, -y
			
		def setPupilSize(self, pupilSize):
			
			"""
			desc:
				Sets the most recently recorded pupil size, and estimate a new
				likelihood value.
				
			arguments:
				pupilSize:		A pupil-size value.
			"""
			
			self.lPrediction.append(self.brightness)
			self.lPupilSize.append(pupilSize)
			if len(self.lPupilSize) > 1:
				pupilSizeChange = 1. * self.lPupilSize[-1] / self.lPupilSize[-2]
				if self.lPrediction[-1] == 1 and self.lPrediction[-2] == -1:
					likelihood = self.lLikelihood[-1] / pupilSizeChange
				elif self.lPrediction[-1] == -1 and self.lPrediction[-2] == 1:
					likelihood = self.lLikelihood[-1] * pupilSizeChange
				else:
					likelihood = self.lLikelihood[-1]
				self.lLikelihood.append(likelihood)
				
		def setXY(self, xy):
			
			"""
			desc:
				Sets the position of the item.
				
			arguments:
				xy:		An xy coordinate tuple.
			"""
			
			self.xy = xy
			self.stim.pos = xy
			self.background.pos = xy
			self.mirror.pos = -xy[0], -xy[1]
			
		def show(self, background=True, gazePos=None):
			
			"""
			desc:
				Shows the item.
				
			keywords:
				background:	
								Indicates whether background patch should be shown
								as well.
				gazePos:	
								An (x,y) tuple with the most recent gaze position,
								used to perform retinal stabilization.
			"""
	
			if gazePos != None:
				gx, gy = gazePos
				gx -= xc
				gy -= yc
				self.background.setPos( (self.xy[0]+gx, self.xy[1]-gy) )
			if background:
				self.background.draw()
				if self.showMirror:
					self.mirror.draw()
			self.stim.setHeight(
				int(self.size*self.likelihood()/self.itemArray.meanLikelihood()))
			self.stim.draw()
			
		def focus(self, steps=50):
			
			"""
			desc:
				Moves the item to the display center, indicating that it has been
				selected.
				
			keywords:
				steps:		The number of steps of the animation.
			"""
			
			x = np.linspace(self.xy[0], 0, steps)
			y = np.linspace(self.xy[1], 0, steps)		
			for i in range(steps):
				self.background.pos = x[i],y[i]
				self.stim.pos = x[i],y[i]
				self.mirror.pos = -x[i],-y[i]
				self.show()
				win.flip()
				
		def log(self, status='normal'):
			
			"""
			desc:
				Logs the item information.
				
			keywords:
				status:		The status of the item.
			"""
					
			exp.pygaze_eyetracker.log((u'item id="%s" status=%s likelihood=%s ecc=%s angle=%s '
				u'size=%s brightness=%s color=%s opacity=%s x=%s y=%s') % (
				self.itemId, status, self.likelihood(), self.ecc, self.angle,
				self.size, self.brightness, self.color, self.opacity, self.xy[0],
				self.xy[1]))
	__end__
	set _prepare ""
	set description "Class definition"

define inline_script itemArray
	___run__
	class ItemArray(object):
		
		"""
		desc:
			An array of selectable items.
		"""
		
		def __init__(self, itemIds, stabilize=False, check=True, ecc=310, size=64,
			debug=False):
			
			"""
			desc:
				Constructor.
				
			arguments:
				itemIds:
							A list of item-id strings. There should be an even
							number of elements.
			
			keywords:
				stabilize:
							Indicates whether retinal stabilization should be
							enabled.
				check:		
							Indicates whether the trial should be paused when
							fixation is lost.
				ecc:		The items' eccentricity.
				size:		The items' size.
				debug:		Indicates whether debugging info should be shown.
			"""
			
			if len(itemIds) not in [2, 4, 8, 16, 32]:
				raise Exception('Expecting a power-of-two number of item IDs')
			self.items = []
			self.stabilize = stabilize
			self.check = check
			self.ecc = ecc
			self.size = size		
			self.debug = debug
			brightness = random.choice([1,-1])
			angle = 0
			for itemId in itemIds:			
				self.items.append(Item(self, itemId=itemId, angle=angle,
					ecc=ecc, brightness=brightness, size=size))
				brightness *= -1
				angle += 2*np.pi/len(itemIds)
			self.fixDot = GratingStim(win, tex=None, mask='circle', color='green',
				size=8)
			self.pupilSizeIndicator = TextStim(win, '-', pos=(xc-50, yc-20),
				color='black')
			self.pause = TextStim(win, 'Fixation lost')
				
		def show(self, background=True):
			
			"""
			desc:
				Shows the ItemArray.
				
			keywords:
				background:		
								Indicates whether the backgrounds of the items
								should be shown as well.
			"""
					
			if self.check:
				nErr = 0
				while True:
					gx, gy = exp.pygaze_eyetracker.sample()				
					gx -= xc
					gy -= yc
					err = np.sqrt(gx**2+gy**2)
					if err <= 100:
						break
					nErr += 1
					if nErr > 10:
						exp.pygaze_eyetracker.log('pause fixation_lost')
						self.pause.draw()
						win.flip()
						my_keyboard.flush()					
			if self.stabilize:
				gazePos = xy
			else:
				gazePos = None
			for item in self.items:			
				item.show(background=background, gazePos=gazePos)
			self.fixDot.draw()
			if self.debug:
				self.pupilSizeIndicator.draw()
			win.flip()
			
		def meanLikelihood(self):
			
			"""
			returns:
				The mean likelihood of all items.
			"""
			
			return np.mean([item.likelihood() for item in self.items])
			
		def invert(self, dur=500):
			
			"""
			desc:
				Inverts the brightness of all items.
				
			keywords:
				steps:	The duration of the inversion animation.
			"""
			
			f = np.linspace(1, -1, dur)
			oldBrightness = np.array([item.brightness for item in self.items])
			t0 = exp.time()
			i = 0
			while i < dur:			
				n = 0			
				for item in self.items:
					item.setBrightness(oldBrightness[n] * f[i])
					n += 1
				print 'i = %s' % i
				self.show()
				t1 = exp.time()
				i = int(t1-t0)
			n = 0
			for item in self.items:
				item.setBrightness(oldBrightness[n] * f[-1])
				n += 1
				
		def setMode2(self, mode2, steps=100):
			
			"""
			desc:
				See mode2 description in __init__().
				
			arguments:
				mode2:	See __init__().
			"""
			
			mode2 = str(mode2)
			assert(mode2 in ['180', '90up', '90down', '90upmirror', '90downmirror'])
			if len(self.items) != 2 or mode2 == '180':
				return
			if '90down' in mode2:
				# If item 0 is closer to the -.25pi angle than item 1
				if np.abs(self.items[0].angle+.25*np.pi) < U+005C
					np.abs(self.items[1].angle+.25*np.pi):			
					a0 = -.25 * np.pi
					a1 = -.75 * np.pi
				else:
					a0 = -.75 * np.pi
					a1 = -.25 * np.pi				
			elif '90up' in mode2:
				# If item 0 is closer to the .25pi angle than item 1
				if np.abs(self.items[0].angle-.25*np.pi) < U+005C
					np.abs(self.items[1].angle-.25*np.pi):			
					a0 = .25 * np.pi
					a1 = .75 * np.pi
				else:
					a0 = .75 * np.pi
					a1 = .25 * np.pi				
			if steps > 0:
				x0 = self.items[0].ecc*np.cos(a0)
				y0 = self.items[0].ecc*np.sin(a0)
				x1 = self.items[1].ecc*np.cos(a1)
				y1 = self.items[1].ecc*np.sin(a1)
				traceX0 = np.linspace(self.items[0].xy[0], x0, steps)
				traceY0 = np.linspace(self.items[0].xy[1], y0, steps)
				traceX1 = np.linspace(self.items[1].xy[0], x1, steps)
				traceY1 = np.linspace(self.items[1].xy[1], y1, steps)
				for i in range(steps):
					self.items[0].setXY((traceX0[i], traceY0[i]))
					self.items[1].setXY((traceX1[i], traceY1[i]))
					self.show()
			self.items[0].setAngle(a0)
			self.items[1].setAngle(a1)				
			if 'mirror' in mode2:
				self.items[0].showMirror = True
				self.items[1].showMirror = True
				
		def selectionLoop(self, initialSleep=1000, invertSteps=500, adaptDur=500,
			collectDur=250, target=None, mode2='180'):
			
			"""
			desc:
				Starts the selection loop, which ends when only one item is left.
				
			keywords:
				initialSleep:	The initial sleep duration.
				invertStep:		The number of franes for the invert animation.
				adaptDur:		The duration of the adaptation period.
				collectDur:		The duration of the pupil-size-collection period.
				target:			The target to be selected.
				mode2:
							Indicates the mode of the final selection round, in
							which only two items are left. Should be '180', '90up',
							'90down', '90upmirror', or '90downmirror'.
				
			returns:
				An (item, rounds) tuple containing the winning item and the number
				of rounds that the selection loop took.
			"""
			
			self.setMode2(mode2, steps=0)
			exp.pygaze_eyetracker.log('start_selection_loop')
			exp.pygaze_eyetracker.log('var target %s' % target)		
			exp.pygaze_eyetracker.log('var mode2 %s' % mode2)
			exp.pygaze_eyetracker.log('var stabilize %s' % self.stabilize)
			for item in self.items:
				item.log(status='init')		
			rounds = 0
			self.show(background=False)
			exp.sleep(initialSleep)
			self.show()
			collectPupilTrace(self, initialSleep)
			while True:				
				exp.pygaze_eyetracker.log('start_round %d' % rounds)			
				exp.pygaze_eyetracker.log('start_invert')
				self.invert(dur=invertSteps)
				exp.pygaze_eyetracker.log('end_invert')
				exp.pygaze_eyetracker.log('start_adaptation')
				collectPupilTrace(self, adaptDur)
				exp.pygaze_eyetracker.log('end_adaptation')
				exp.pygaze_eyetracker.log('start_collection')
				a = collectPupilTrace(self, collectDur)
				exp.pygaze_eyetracker.log('end_collection')
				meanPupilSize = np.median(a)
				self.pupilSizeIndicator.setText(str(meanPupilSize))
				for item in self.items:
					item.setPupilSize(meanPupilSize)				
				_items = []
				prune = False
				for item in self.items:
					if item.likelihood()*2 >= self.meanLikelihood():
						item.log(status='keep')
						_items.append(item)
					else:
						item.log(status='prune')
						prune = True					
				self.items = _items			
				if prune:
					exp.pygaze_eyetracker.log('prune yes')
					self.setMode2(mode2)
					brightness = random.choice([1,-1])
					for item in self.items:
						item.setBrightness(brightness)
						brightness *= -1
				else:
					exp.pygaze_eyetracker.log('prune no')
				exp.pygaze_eyetracker.log('end_round')
				rounds += 1
				# Break if the target has been eliminated, if a target was specified
				if target != None:
					hit = False
					for item in self.items:
						if item.itemId == target:
							hit = True
					if not hit:
						break
				if len(self.items) == 1:
					break								
			if len(self.items) > 1:
				exp.pygaze_eyetracker.log('var correct 0')
				Item(self, '?', 0, self.ecc).focus()
				winner = None
			else:
				exp.pygaze_eyetracker.log('var correct 1')
				winner = self.items[0]
				winner.log(status='winner')
				winner.focus()
			exp.pygaze_eyetracker.log('var rounds %d' % rounds)
			exp.pygaze_eyetracker.log('end_selection_loop')
			return winner, rounds
	__end__
	set _prepare ""
	set description "Class definition"

define keyboard_response keyboard_response

define logger logger
	set description "Logs experimental data"

define pygaze_drift_correct pygaze_drift_correct
	set xpos "0"
	set draw_target "yes"
	set ypos "0"
	set target_style "default"
	set target_color "[foreground]"
	set fixation_triggered "yes"
	set description "Perform eye-tracker drift correction"

define pygaze_init pygaze_init
	set sacc_acc_thr "9500"
	set description "Initialize and calibrate eye tracker"
	set tracker_type "EyeLink"
	set sacc_vel_thr "35"
	set calibrate "yes"
	set _logfile "automatic"

define pygaze_log pygaze_log
	set msg ""
	set throttle "2"
	set description "Writes information to the eye-tracker logfile"
	set auto_log "yes"

define pygaze_start_recording pygaze_start_recording
	set status_msg "start_trial [count_exp1_sequence]"
	set description "Puts the eye tracker into recording mode"

define pygaze_stop_recording pygaze_stop_recording

define sequence python_definitions
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run globals "always"
	run smoothing "always"
	run speech "always"
	run item "always"
	run itemArray "always"
	run eye_tracker "always"

define inline_script select_target
	___run__
	ia = ItemArray(list(self.get('itemIds')))
	items = ia.items[:]
	t0 = self.time()
	winner, rounds = ia.selectionLoop(
		target=self.get('target'),
		mode2=self.get('mode2'))
	t1 = self.time()
	rt = .001 * (t1-t0)
	exp.set('winner', winner)
	exp.set('rounds', rounds)
	exp.set('loop_rt', rt)
	__end__
	set _prepare ""
	set description "Executes Python code"

define sketchpad sketchpad
	set duration "keypress"
	set description "Displays stimuli"
	draw textline 0 -96 "Attend to" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 96 "Press any key to begin" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 0 "[target]" center=1 color=green font_family="mono" font_size=64 font_italic=no font_bold=no show_if="always" html="yes"

define inline_script smoothing
	___run__
	import numpy
	
	def smooth(x, window_len=11, window='hanning'):
		"""
		desc:
			Smooths an array using a window with requested size and shape.
			
		source:
			<http://wiki.scipy.org/Cookbook/SignalSmooth>
		
		arguments:
			x:				The input array.
			
		keywords:
			window_len: 	The length of the window. Should be an odd integer.
			window:			The type of window from 'flat', 'hanning', 'hamming',
							'bartlett', 'blackman'.
	
		returns:
			A smoothed array.		
		"""
	
		if x.ndim != 1:
			raise ValueError, "smooth only accepts 1 dimension arrays."
		if x.size < window_len:
			raise ValueError, "Input vector needs to be bigger than window size."
		if window_len<3:
			return x
		if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
			raise ValueError, "Window is on of 'flat', 'hanning', 'hamming','bartlett', 'blackman'"
		s=numpy.r_[x[window_len-1:0:-1],x,x[-1:-window_len:-1]]
		if window == 'flat': #moving average
			w=numpy.ones(window_len,'d')
		else:
			w=eval('numpy.'+window+'(window_len)')
		y=numpy.convolve(w/w.sum(),s,mode='valid')
		return y
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script speak_target
	set _run "say('Attend to %s' % self.get('target'))"
	set _prepare ""
	set description "Executes Python code"

define inline_script speech
	___run__
	def say(msg):
		
		"""
		desc:
			Speak a message with the espeak synthesizer (if available).
			
		arguments:
			msg:	The message to speak.
		"""
		
		try:
			subprocess.Popen(['espeak', msg])
		except:
			print('Text synthesis not available!')
	__end__
	set _prepare ""
	set description "Executes Python code"

