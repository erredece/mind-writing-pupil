# Generated by OpenSesame 2.8.2 (Gutsy Gibson)
# Thu Jul 03 16:11:47 2014 (nt)
# <http://www.cogsci.nl/opensesame>

set mouse_backend "psycho"
set subject_parity "even"
set height "1024"
set font_family "mono"
set font_italic "no"
set synth_backend "legacy"
set title "P0015.1 PLR BCI Pilot"
set coordinates "relative"
set start "experiment"
set sampler_backend "legacy"
set transparent_variables "no"
set foreground "white"
set font_bold "no"
set description "Default description"
set background "gray"
set font_size "18"
set keyboard_backend "psycho"
set canvas_backend "psycho"
set compensation "0"
set bidi "no"
set subject_nr "0"
set width "1280"

define inline_script calibrate
	___run__
	ia = ItemArray(['X']*6)
	ia.show()
	
	nCycles = 10
	dur = 4000
	
	exp.eyelink.start_recording()
	
	aTrace = np.zeros([nCycles, dur/10])
	
	for i in range(nCycles):
		ia.invert()
		aTrace[i] = collectPupilTrace(ia, dur)
		
	exp.eyelink.stop_recording()
	
	mTrace = smooth(aTrace.mean(axis=0), window_len=11)
	mVel = mTrace[1:] - mTrace[:-1]
	velThr = np.abs(mVel).max() * .2
	iStable = np.where(np.abs(mVel) >= velThr)[0][-1]
	
	
	import os
	from matplotlib import pyplot as plt
	plt.subplot(211)
	plt.title('%d' % (iStable))
	plt.plot(np.rot90(aTrace), '--', color='gray')
	plt.plot(aTrace.mean(axis=0), '-', color='black')
	plt.xlim(0, len(mVel))
	plt.axvline(iStable, linestyle='--', color='gray')
	
	plt.subplot(212)
	plt.plot(mVel)
	plt.xlim(0, len(mVel))
	plt.axhline(-velThr, linestyle='--', color='gray')
	plt.axhline(velThr, linestyle='--', color='gray')
	plt.axvline(iStable, linestyle='--', color='gray')
	path = os.path.join(exp.experiment_path, 'plots/calibrate.png')	
	plt.savefig(path)
	plt.clf()
	exp.set('plot_path', path)
	
		
		
	__end__
	set _prepare ""
	set description "Executes Python code"

define feedback calibrationFeedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw image 0 0 "[plot_path]" scale=1 center=1 show_if="always"

define sequence calibrationSequence
	set flush_keyboard "yes"
	set description "Runs a number of items in sequence"
	run calibrate "always"
	run calibrationFeedback "always"

define sequence experiment
	run eyelink_calibrate "always"
	run globals "always"
	run smoothing "always"
	run eye_tracker "always"
	run item "always"
	run itemArray "always"
	run calibrationSequence "never"
	run loop "always"

define inline_script eye_tracker
	___run__
	def collectPupilTrace(itemArray, dur, fd=10):
		
		t0 = self.time()
		a = np.zeros(dur/fd)
		_dt = 0
		while _dt < dur:		
			itemArray.show()
			ps = exp.eyelink.pupil_size()
			dt = self.time()-t0
			a[int(_dt/fd):int(dt/fd)] = ps
			_dt = dt
			my_keyboard.flush()
		return a
	
	__end__
	set _prepare ""
	set description "Executes Python code"

define eyelink_calibrate eyelink_calibrate
	set sacc_vel_thresh "35"
	set cal_beep "yes"
	set description "Calibration/ initialization plugin for the Eyelink series of eye trackers (SR-Research)"
	set sacc_acc_thresh "9500"
	set cal_target_size "16"
	set force_drift_correct "yes"
	set tracker_attached "Yes"

define eyelink_drift_correct eyelink_drift_correct
	set mode "Automatic (fixation triggered)"
	set xpos "0"
	set description "Drift correction plugin for the Eyelink series of eye trackers (SR-Research)"
	set ypos "0"

define inline_script globals
	___run__
	import string
	import numpy as np
	import random
	from psychopy.visual import TextStim, GratingStim
	from openexp.keyboard import keyboard
	
	my_keyboard = keyboard(exp, timeout=0)
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script item
	___run__
	class Item(object):
		
		def __init__(self, itemArray, itemId, angle, ecc, opacity=.5, color='green',
			size=128, brightness=1):
			
			self.itemArray = itemArray
			self.itemId = itemId
			self.opacity = .5
			self.color = color
			self.size = size
			self.lLikelihood = [1]
			self.angle = angle
			self.brightness = brightness
			self.ecc = ecc
			x = self.ecc * np.cos(self.angle)
			y = self.ecc * np.sin(self.angle)
			self.xy = x,y
			self.background = GratingStim(win, tex=None, mask='raisedCos',
				pos=self.xy, color=self.brightness, size=size*2)
			self.stim = TextStim(win, itemId, pos=self.xy, opacity=self.opacity,
				color=self.color, height=size)
			self.lPrediction = []
			self.lPupilSize = []
										
		def likelihood(self):
			
			return self.lLikelihood[-1]
			
		def setBrightness(self, brightness):
			
			self.background.setColor(brightness)
			self.brightness = brightness
			
		def setPupilSize(self, pupilSize):
			
			self.lPrediction.append(self.brightness)
			self.lPupilSize.append(pupilSize)
			if len(self.lPupilSize) > 1:
				pupilSizeChange = 1. * self.lPupilSize[-1] / self.lPupilSize[-2]
				if self.lPrediction[-1] == 1 and self.lPrediction[-2] == -1:
					likelihood = self.lLikelihood[-1] / pupilSizeChange
				elif self.lPrediction[-1] == -1 and self.lPrediction[-2] == 1:
					likelihood = self.lLikelihood[-1] * pupilSizeChange
				else:
					likelihood = self.lLikelihood[-1]
				self.lLikelihood.append(likelihood)
			
		def show(self, background=True, gazePos=None):
	
			if gazePos != None:
				gx, gy = gazePos
				gx -= 640
				gy -= 512
				self.background.setPos( (self.xy[0]+gx, self.xy[1]-gy) )
			if background:
				self.background.draw()
			self.stim.setHeight(
				int(self.size*self.likelihood()/self.itemArray.meanLikelihood()))
			self.stim.draw()
			
		def focus(self, steps=100):
			
			x = np.linspace(self.xy[0], 0, steps)
			y = np.linspace(self.xy[1], 0, steps)		
			for i in range(steps):
				self.background.pos = x[i],y[i]
				self.stim.pos = x[i],y[i]
				self.show()
				win.flip()
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script itemArray
	___run__
	class ItemArray(object):
		
		def __init__(self, itemIds):
			
			self.items = []
			brightness = random.choice([1,-1])
			ecc = 310
			angle = 0
			for itemId in itemIds:			
				self.items.append(Item(self, itemId=itemId, angle=angle,
					ecc=ecc, brightness=brightness))
				brightness *= -1
				angle += 2*np.pi/len(itemIds)
			self.fixDot = GratingStim(win, tex=None, mask='circle', color='green',
				size=8)
				
		def show(self, background=True):
			
			gazePos = exp.eyelink.sample()
			for item in self.items:			
				item.show(background=background, gazePos=gazePos)
			self.fixDot.draw()
			win.flip()
			
		def meanLikelihood(self):
			
			return np.mean([item.likelihood() for item in self.items])
			
		def invert(self, steps=50):
			
			f = np.linspace(1, -1, steps)
			oldBrightness = np.array([item.brightness for item in self.items])
			for i in range(steps):
				n = 0			
				for item in self.items:
					item.setBrightness(oldBrightness[n] * f[i])
					n += 1
				self.show()
				
		def selectionLoop(self):
			
			rounds = 0
			exp.eyelink.start_recording()		
			self.show(background=False)
			exp.sleep(1000)
			self.show()
			collectPupilTrace(self, 1000)
			while True:
				self.invert()
				collectPupilTrace(self, 500)
				a = collectPupilTrace(self, 250)
				meanPupilSize = np.median(a)
				for item in self.items:
					item.setPupilSize(meanPupilSize)				
				_items = []
				prune = False
				for item in self.items:
					if item.likelihood()*2 >= self.meanLikelihood():
						_items.append(item)
					else:
						prune = True
				self.items = _items
				if prune:
					brightness = random.choice([1,-1])
					for item in self.items:
						item.setBrightness(brightness)
						brightness *= -1
				rounds += 1
				if len(self.items) == 1:
					break				
			exp.eyelink.stop_recording()		
			self.items[0].focus()
			return self.items[0], rounds
	
		
	__end__
	set _prepare ""
	set description "Executes Python code"

define keyboard_response keyboard_response

define logger logger
	set ignore_missing "yes"
	set description "Logs experimental data"
	set auto_log "no"
	set use_quotes "yes"
	log "winnerId"
	log "setSize"
	log "rounds"
	log "correct"

define loop loop
	set repeat "2"
	set description "Repeatedly runs another item"
	set item "sequence"
	set break_if "never"
	set column_order "setSize"
	set cycles "3"
	set order "random"
	setcycle 0 setSize "2"
	setcycle 1 setSize "4"
	setcycle 2 setSize "8"
	run sequence

define inline_script select_target
	___run__
	ia = ItemArray(itemIds)
	items = ia.items[:]
	winner, rounds = ia.selectionLoop()
	exp.set('rounds', rounds)
	exp.set('winner', winner.itemId)
	__end__
	set _prepare ""
	set description "Executes Python code"

define sequence sequence
	run trial_init "always"
	run sketchpad "always"
	run eyelink_drift_correct "always"
	run select_target "always"
	run keyboard_response "always"
	run logger "always"

define sketchpad sketchpad
	set duration "keypress"
	set description "Displays stimuli"
	draw textline 0 0 "Attend [target]" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"

define inline_script smoothing
	___run__
	import numpy
	
	def smooth(x,window_len=11,window='hanning'):
		"""smooth the data using a window with requested size.
		
		This method is based on the convolution of a scaled window with the signal.
		The signal is prepared by introducing reflected copies of the signal 
		(with the window size) in both ends so that transient parts are minimized
		in the begining and end part of the output signal.
		
		input:
			x: the input signal 
			window_len: the dimension of the smoothing window; should be an odd integer
			window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
				flat window will produce a moving average smoothing.
	
		output:
			the smoothed signal
			
		example:
	
		t=linspace(-2,2,0.1)
		x=sin(t)+randn(len(t))*0.1
		y=smooth(x)
		
		see also: 
		
		numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
		scipy.signal.lfilter
	 
		TODO: the window parameter could be the window itself if an array instead of a string
		NOTE: length(output) != length(input), to correct this: return y[(window_len/2-1):-(window_len/2)] instead of just y.
		"""
	
		if x.ndim != 1:
			raise ValueError, "smooth only accepts 1 dimension arrays."
	
		if x.size < window_len:
			raise ValueError, "Input vector needs to be bigger than window size."
	
	
		if window_len<3:
			return x
	
	
		if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
			raise ValueError, "Window is on of 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'"
	
	
		s=numpy.r_[x[window_len-1:0:-1],x,x[-1:-window_len:-1]]
		#print(len(s))
		if window == 'flat': #moving average
			w=numpy.ones(window_len,'d')
		else:
			w=eval('numpy.'+window+'(window_len)')
	
		y=numpy.convolve(w/w.sum(),s,mode='valid')
		return y
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script trial_init
	set _run ""
	___prepare__
	from random import shuffle, choice
	from openexp.keyboard import keyboard
	import string
	
	setSize = self.get('setSize')
	itemIds = list(string.uppercase[:setSize])
	shuffle(itemIds)
	exp.set('target', choice(itemIds))
	__end__
	set description "Executes Python code"

