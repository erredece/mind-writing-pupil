# Generated by OpenSesame 2.8.2 (Gutsy Gibson)
# Wed Jul 02 12:22:07 2014 (nt)
# <http://www.cogsci.nl/opensesame>

set mouse_backend "psycho"
set subject_parity "even"
set height "768"
set font_family "mono"
set font_italic "no"
set synth_backend "legacy"
set title "P0015.1 PLR BCI Pilot"
set coordinates "relative"
set start "experiment"
set sampler_backend "legacy"
set transparent_variables "no"
set foreground "white"
set font_bold "no"
set description "Default description"
set background "gray"
set font_size "18"
set keyboard_backend "psycho"
set canvas_backend "psycho"
set compensation "0"
set bidi "no"
set subject_nr "0"
set width "1024"

define feedback _feedback
	draw image 0 0 "[plot_path]" scale=1.0 center=1 show_if="always"

define inline_script background
	set _run ""
	___prepare__
	import numpy as np
	from psychopy.visual import RadialStim, TextStim, GratingStim
	from itertools import permutations
	from scipy.stats import linregress
	import random
	
	class Background(object):
		
		def __init__(self, N=4, size=1024):
				
			self.size = size
			self.step = 0
			self.N = N
			self.mask = np.ones( self.N )
			
			# Create a texture of alternating brightness
			self.altTex = [1]
			for i in range(N-1):
				self.altTex.append(self.altTex[-1]*-1)
			self.tex = np.array( [self.altTex] )		
			self.stim = RadialStim(win, tex=self.tex, angularCycles=1,
				radialCycles=0, size=2*size)
			self.hole = GratingStim(win, tex=None, mask='raisedCos', color='gray',
				size=self.size/3)		
			self.fixDot = GratingStim(win, tex=None, mask='circle', color='green',
				size=8)
			self.step = 0
					
		def cycleLen(self):
		
			return self.tex.shape[0]
			
		def setTex(self):
			
			# If there are only two options left, they should flip in counterphase
			if np.sum(self.mask) == 2:
				print 'Two left %s' % np.where(self.mask == 1)
				self.tex = self.tex[0] * self.mask
				i1 = np.where(self.mask == 1)[0][0]
				i2 = np.where(self.mask == 1)[0][1]
				if self.tex[i1] * self.tex[i2] < 0:
					self.tex *= -1
				else:
					self.tex[i1] = -1
					self.tex[i2] = 1
				print 'Only %d and %d left' % (i1, i2)
			else:							
				while True:
					random.shuffle(self.altTex)
					newTex = np.array(self.altTex) * self.mask
					nChange = np.sum(newTex != self.tex)
					if nChange >= 2:
						break
				self.tex = newTex
			#self.tex = np.linspace(-1, 1, self.N)
			print 'TEX = %s' % self.tex
			self.tex.shape = 1, len(self.tex)		
			self.stim.tex = self.tex
			self.step += 1
					
		def show(self):
			
			self.stim.draw()
			self.hole.draw()
			self.fixDot.draw()
	__end__
	set description "Executes Python code"

define inline_script calibrate
	___run__
	background = Background()
	
	dur = 2000
	margin = 100
	
	exp.eyelink.start_recording()
	
	cycles = 2*background.cycleLen()
	
	aTrace = np.zeros( (dur, cycles) )
	for i in range(cycles):
		background.setTex()
		background.show()	
		win.flip()
		t = self.time()
		j = 0
		while self.time() - t < dur:
			aTrace[j, i] = exp.eyelink.pupil_size()
			j += 1
			self.sleep(1)
			
	exp.eyelink.stop_recording()
			
	aTrace = aTrace[:dur-500]
	mTrace = smooth(aTrace.mean(axis=1), window_len=101)
	mVel = mTrace[1:] - mTrace[:-1]
	
	velThr = np.abs(mVel).max() * .2
	
	iStable = np.where(np.abs(mVel) >= velThr)[0][-1]
	
	import os
	from matplotlib import pyplot as plt
	plt.subplot(211)
	plt.title('%d' % (iStable))
	plt.plot(aTrace, '--', color='gray')
	plt.plot(aTrace.mean(axis=1), '-', color='black')
	plt.xlim(0, len(mVel))
	plt.axvline(iStable, linestyle='--', color='gray')
	
	plt.subplot(212)
	plt.plot(mVel)
	plt.xlim(0, len(mVel))
	plt.axhline(-velThr, linestyle='--', color='gray')
	plt.axhline(velThr, linestyle='--', color='gray')
	plt.axvline(iStable, linestyle='--', color='gray')
	path = os.path.join(exp.experiment_path, 'plots/calibrate.png')	
	plt.savefig(path)
	plt.clf()
	exp.set('plot_path', path)
		
	
	__end__
	set _prepare ""
	set description "Executes Python code"

define sequence experiment
	run eyelink_calibrate "always"
	run smoothing "always"
	run target "always"
	run background "always"
	run calibrate "never"
	run _feedback "never"
	run loop "always"

define eyelink_calibrate eyelink_calibrate
	set sacc_vel_thresh "35"
	set cal_beep "yes"
	set description "Calibration/ initialization plugin for the Eyelink series of eye trackers (SR-Research)"
	set sacc_acc_thresh "9500"
	set cal_target_size "16"
	set force_drift_correct "yes"
	set tracker_attached "Yes"

define eyelink_drift_correct eyelink_drift_correct
	set ypos "0"
	set xpos "0"
	set mode "Automatic (fixation triggered)"
	set description "Drift correction plugin for the Eyelink series of eye trackers (SR-Research)"

define eyelink_start_recording eyelink_start_recording

define eyelink_stop_recording eyelink_stop_recording

define feedback feedback
	set duration "keypress"
	set reset_variables "yes"
	set description "Provides feedback to the participant"
	draw image 0 0 "[plotPath]" scale=1 center=1 show_if="always"
	draw textline 0 320 "Press any key to continue" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 -96 "Target was [target]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"
	draw textline 0 -32 "You selected [winnerId]" center=1 color=black font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"

define logger logger
	set ignore_missing "yes"
	set description "Logs experimental data"
	set auto_log "no"
	set use_quotes "yes"
	log "winnerId"
	log "setSize"
	log "rounds"
	log "correct"

define loop loop
	set repeat "2"
	set description "Repeatedly runs another item"
	set item "sequence"
	set break_if "never"
	set column_order "setSize"
	set cycles "5"
	set order "random"
	setcycle 0 setSize "2"
	setcycle 1 setSize "3"
	setcycle 2 setSize "4"
	setcycle 3 setSize "5"
	setcycle 4 setSize "6"
	run sequence

define inline_script select_target
	___run__
	background.show()
	for target in targets:
		target.show()
	win.flip()
	self.sleep(1000)
	
	targetsLeft = len(targets)
	rounds = 0
	while targetsLeft > 1:
		rounds += 1
		background.setTex()
		background.show()	
		for target in targets:
			target.show()
		win.flip()		
		if my_keyboard.get_key(timeout=adaptDur)[0] != None:
			break
		t = self.time()
		lPupilSize = []	
		while self.time() - t < collectDur:
			lPupilSize.append(exp.eyelink.pupil_size())
			self.sleep(1)
		mPupilSize = np.mean(lPupilSize)
		for target in targets:
			target.setPupilSize(mPupilSize)
			
		lLikelihood = []
		for target in targets:
			if target.enabled:
				lLikelihood.append(target.likelihood())
		maxLikelihood = np.max(lLikelihood)
		meanLikelihood = np.mean(lLikelihood)
			
		for target in targets:
			target.setMeanlikelihood(meanLikelihood)
			if target.enabled and maxLikelihood > likelihoodThr*target.likelihood():
				target.disable()
				targetsLeft -= 1
				
	background.setTex()
	background.show()
	for target in targets:
		if target.enabled:
			target.show()
			exp.set('winnerId', target.letter)
			if target.letter == self.get('target'):
				exp.set('correct', 1)
			else:
				exp.set('correct', 0)
	win.flip()
	
	exp.set('rounds', rounds)
	
	import os
	from matplotlib import pyplot as plt
	plt.subplot(2, 2+len(targets)/2, 1)
	plt.plot(targets[0].lPupilSize)
	
	i = 3
	for target in targets:
		plt.subplot(2, 2+len(targets)/2, i)
		plt.title(target.letter)
		plt.plot(-1*np.array(target.lPrediction))
		plt.ylim(-1, maxLikelihood+1)
		plt.plot(target.lLikelihood, color='red')
		i += 1
	
	path = os.path.join(exp.experiment_path, 'plots/results-%.3d.png' U+005C
		% self.get('count_sequence'))	
	plt.savefig(path)
	plt.clf()
	exp.set('plotPath', path)
	__end__
	set _prepare ""
	set description "Executes Python code"

define sequence sequence
	run trial_init "always"
	run sketchpad "always"
	run eyelink_drift_correct "always"
	run eyelink_start_recording "always"
	run select_target "always"
	run eyelink_stop_recording "always"
	run feedback "always"
	run logger "always"

define sketchpad sketchpad
	set duration "keypress"
	set description "Displays stimuli"
	draw textline 0 0 "Attend [target]" center=1 color=white font_family="mono" font_size=18 font_italic=no font_bold=no show_if="always" html="yes"

define inline_script smoothing
	___run__
	import numpy
	
	def smooth(x,window_len=11,window='hanning'):
		"""smooth the data using a window with requested size.
		
		This method is based on the convolution of a scaled window with the signal.
		The signal is prepared by introducing reflected copies of the signal 
		(with the window size) in both ends so that transient parts are minimized
		in the begining and end part of the output signal.
		
		input:
			x: the input signal 
			window_len: the dimension of the smoothing window; should be an odd integer
			window: the type of window from 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'
				flat window will produce a moving average smoothing.
	
		output:
			the smoothed signal
			
		example:
	
		t=linspace(-2,2,0.1)
		x=sin(t)+randn(len(t))*0.1
		y=smooth(x)
		
		see also: 
		
		numpy.hanning, numpy.hamming, numpy.bartlett, numpy.blackman, numpy.convolve
		scipy.signal.lfilter
	 
		TODO: the window parameter could be the window itself if an array instead of a string
		NOTE: length(output) != length(input), to correct this: return y[(window_len/2-1):-(window_len/2)] instead of just y.
		"""
	
		if x.ndim != 1:
			raise ValueError, "smooth only accepts 1 dimension arrays."
	
		if x.size < window_len:
			raise ValueError, "Input vector needs to be bigger than window size."
	
	
		if window_len<3:
			return x
	
	
		if not window in ['flat', 'hanning', 'hamming', 'bartlett', 'blackman']:
			raise ValueError, "Window is on of 'flat', 'hanning', 'hamming', 'bartlett', 'blackman'"
	
	
		s=numpy.r_[x[window_len-1:0:-1],x,x[-1:-window_len:-1]]
		#print(len(s))
		if window == 'flat': #moving average
			w=numpy.ones(window_len,'d')
		else:
			w=eval('numpy.'+window+'(window_len)')
	
		y=numpy.convolve(w/w.sum(),s,mode='valid')
		return y
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script target
	___run__
	class Target(object):
		
		def __init__(self, background, letter, pos, opacity=.5, color='green',
			size=128):
			
			self.background = background		
			self.letter = letter
			self.opacity = .5
			self.color = color
			self.size = size
			self.pos = pos
			self.lLikelihood = [1]
			self.meanLikelihood = 1
			self.enabled = True
			r = self.background.size/3
			a = np.pi/2 - np.pi/self.background.N U+005C
				- (2*np.pi/self.background.N) * self.pos
			x = r * np.cos(a)
			y = r * np.sin(a)
			self.xy = x,y
			self.stim = TextStim(win, letter, pos=self.xy, opacity=self.opacity,
				color=self.color, height=size)
			self.lPrediction = []
			self.lPupilSize = []
			
		def disable(self):
			
			self.background.mask[self.pos] = 0
			self.enabled = False
						
		def prediction(self):
			
			return self.background.tex[0, self.pos]
			
		def likelihood(self):
			
			return self.lLikelihood[-1]
			
		def setMeanlikelihood(self, meanLikelihood):
			
			self.meanLikelihood = meanLikelihood
			
		def setPupilSize(self, pupilSize):
			
			self.lPrediction.append(self.prediction())
			self.lPupilSize.append(pupilSize)
			
			if self.enabled:
				if len(self.lPupilSize) > 1:
					pupilSizeChange = 1. * self.lPupilSize[-1] / self.lPupilSize[-2]
					if self.lPrediction[-1] == 1 and self.lPrediction[-2] == -1:
						likelihood = self.lLikelihood[-1] / pupilSizeChange
					elif self.lPrediction[-1] == -1 and self.lPrediction[-2] == 1:
						likelihood = self.lLikelihood[-1] * pupilSizeChange
					else:
						likelihood = self.lLikelihood[-1]
					self.lLikelihood.append(likelihood)
			else:
				self.lLikelihood.append(0)
			
		def show(self):
		
			if self.enabled:
				self.stim.setHeight(
					int(self.size*self.likelihood()/self.meanLikelihood))
				self.stim.draw()
	__end__
	set _prepare ""
	set description "Executes Python code"

define inline_script trial_init
	set _run ""
	___prepare__
	from random import shuffle, choice
	from openexp.keyboard import keyboard
	import string
	
	setSize = self.get('setSize')
	letters = list(string.uppercase[:setSize])
	shuffle(letters)
	colors = ['red', 'green', 'blue', 'yellow', 'pink', 'brown', 'orange',
		'purple']
	shuffle(colors)
	my_keyboard = keyboard(exp)
	background = Background(N=setSize)
	pos = 0
	targets = []
	for letter in letters:
		target = Target(background, letter, pos=pos, color=colors.pop())
		pos += 1
		targets.append(target)
	
	likelihoodThr = 3
	adaptDur = 1000
	collectDur = 200
	
	exp.set('target', choice(letters))
	__end__
	set description "Executes Python code"

